---
title: "Probability of default (PD) model"
author: "Eligijus Bujokas"
date: "12/19/2020"
output: 
  html_document:
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(data.table)
library(ggplot2)
library(zoo)
library(stringr)
library(gridExtra)
library(reshape)
library(pROC)
Sys.setlocale("LC_ALL","C")
```

# Problem overview

The objective is to from the data that is in the *train.csv* file create a model that predicts the probability of default (PD) model. Then, the model is tested on the data that is in the file *test.csv*. 

The model will be a logistic regression model. 

# Reading data

```{r reading data}
train <- fread('data/train.csv')
test <- fread('data/test.csv')

print(head(train))
print(head(test))

print(nrow(train))
print(nrow(test))
```
# Data cleaning 

```{r summary of data}
summary(train)

# Droping NA 
train = na.omit(train)
test = na.omit(test)

# Ensuring the correct data types 
train$term <- as.factor(train$term)
train$emp_length <- as.factor(train$emp_length)
train$home_ownership <- as.factor(train$home_ownership)
train$purpose <- as.factor(train$purpose)
```

# Weight of evidence

To infer what categorical feature values are the most influential in determining bad loan from a good loan we can use the weight of evidence (WOE for short) criteria. For a feature $i$ and the feature level $j$ the $WOE_{i, j}$ is calculated with the following formula:

$$WOE_{i, j} = log \left(\dfrac{P(X_{i}=j|Y=1)}{P(X_{i} = j|Y=0)}\right)$$
Lets define a function in R that calculates the WOE statistic for any given feature. Note, that the dependent variable needs to be called **Y**.

```{r woe}
woe <- function(feature, data){
  # Grouping by the feature and getting the total number of observations in each level
  woeTable <- data[, .N, by=c("Y", feature)] %>% 
    # Seting the names 
    setnames(., c('Y', 'feature', 'N')) %>% 
    # Casting so that Y is in the columns
    cast(., feature ~ Y, value="N") %>% 
    # Converting back to data.table
    data.table(.) %>% 
    # Filling the missing values with 0 
    setnafill(., fill=0, cols=c('good', 'bad')) %>%
    # Getting the proportions of good and bad borrowers in each level of the variable
    .[, c('prop_good', 'prop_bad') := list(good/sum(good), bad/sum(bad))] %>% 
    # Calculating the WOE statistic 
    .[, woe:=log(prop_good/prop_bad)] %>% 
    # Sorting by the woe stat
    .[order(woe, decreasing=TRUE)]
  
  return(woeTable)
}

# Example of the function output:
woeResult = woe('purpose', train)
print(woeResult)

# Defining a function to plot the woe 
plotWoe <- function(ft, woeData){
  p <- ggplot(woeData, aes(x=reorder(feature, woe), y=woe)) + 
            geom_bar(stat="identity", fill="steelblue", color='black') + 
            ggtitle(ft) + 
            labs(x='Feature value') +
            coord_flip()
   return(p)
}
```

## Iterating through all categorical features 

The initial weight of evidence plots:

```{r}
cat_vars <- c("purpose", "emp_length", "term", "home_ownership")
plots <- list()

for(cat_var in cat_vars){
  woeStat <- woe(cat_var, train)
  plots[[cat_var]] <- plotWoe(cat_var, woeStat)
}

grid.arrange(plots$purpose, plots$emp_length, plots$term, plots$home_ownership, ncol = 2, nrow=2)
```

As we can see from the plots, the only adjustment will be needed to emp_length variable. 

```{r adjust emp_length}
adjust_emp_length <- function(x){
  return(ifelse(is.element(x, c("< 1 year")), "< 1 year", "1+ year"))
}

train$emp_length_groups <- sapply(train$emp_length, adjust_emp_length)

woeStat <- woe('emp_length_groups', train)
p <- plotWoe('emp_length_groups', woeStat)
p
```

## Annual income

```{r}
capvalues <- function(x, cap){
  return(min(c(x, cap)))
}

plotWoeNumeric <- function(ft, woeData){
  p <- ggplot(woeData, aes(x=feature, y=woe)) + 
            geom_bar(stat="identity", fill="steelblue", color='black') + 
            ggtitle(ft) + 
            labs(x='Feature value') +
            coord_flip()
   return(p)
}

# Droping the outliers
train$annual_inc_c <- sapply(train$annual_inc, capvalues, cap=300000)

# Ploting the distribution
ggplot(data=train, aes(x=annual_inc_c)) + geom_density(fill='blue')

# Cutting the annual income into 10 equal sized partitions
train$annual_inc_groups = cut(train$annual_inc_c / 1000, 10)

woedf <- woe('annual_inc_groups', train)
plotWoeNumeric('annual_income', woedf)
```

Defining a function for annual income split. 

```{r final_income}
adj_income <- function(x){
  if(x < 30000){
    return("[0,30)")
  } else if (x < 60000){
    return("[30,60)")
  } else if (x < 100000){
    return("[60,100)")
  } else if (x < 200000){
    return("[100,200)")
  } else {
    return("200+")
  }
}

train$annual_inc_groups <- sapply(train$annual_inc, adj_income)

woedf <- woe('annual_inc_groups', train)
plotWoe('Final annual income splits', woedf)
```

## Interest rate

```{r interest_rate}
adj_int_rate <- function(x){
  if (x < 10) {
    return("[0,10)")
  } else if(x < 15){
    return("[10, 15)")
  } else if(x < 25){
    return("[15, 25)")
  } else {
    return("25+")
  }
}

train$int_rate_groups = sapply(train$int_rate, adj_int_rate)
woedf <- woe('int_rate_groups', train)
plotWoe('int_rate_groups', woedf)
```


## DTI 

```{r}
# Droping the outliers
train$dti_c <- sapply(train$dti, capvalues, cap=40)

# Ploting the distribution
ggplot(data=train, aes(x=dti_c)) + geom_density(fill='blue')

# Cutting the annual income into 10 equal sized partitions
train$dti_groups = cut(train$dti_c, 7)

woedf <- woe('dti_groups', train)
plotWoeNumeric('dti', woedf)
```

```{r final_dti}
adj_dti <- function(x){
  if(x < 11){
    return("[0,11)")
  } else if (x < 17){
    return("[11,17)")
  } else if (x < 30){
    return("[17,30)")
  } else {
    return("30+")
  } 
}

train$dti_groups <- sapply(train$dti, adj_dti)

woedf <- woe('dti_groups', train)
plotWoe('Final dti splits', woedf)
```

## Public records

```{r public record}
adj_pub_rec <- function(x){
  if(x==0){
    return("0")
  } else {
    return(">0")
  }
}

train$pub_rec_groups = sapply(train$pub_rec, adj_pub_rec)

woedf <- woe('pub_rec_groups', train)
plotWoeNumeric('pub_rec_groups', woedf)
```

```{r pub_rec_bankruptcy}
train$pub_rec_bankruptcies_groups = sapply(train$pub_rec_bankruptcies, adj_pub_rec)

woedf <- woe('pub_rec_bankruptcies_groups', train)
plotWoeNumeric('pub_rec_bankruptcies_groups', woedf)
```

## Month differences between loan and cr line

```{r month_diff}
# Ploting the distribution
ggplot(data=train, aes(x=month_diff)) + geom_density(fill='blue')

# Cutting the annual income into 10 equal sized partitions
train$month_diff_groups = cut(train$month_diff , 10)

woedf <- woe('month_diff_groups', train)
plotWoeNumeric('month_diff_groups', woedf)
```

```{r final_month_diff}
adj_month_diff <- function(x){
  if(x<70){
    return("[0, 70)")
  } else if (x < 180){
    return("[70, 180)")
  } else if (x < 240) {
    return("[180, 240)")
  } else {
    return("240+")
  }
}

train$month_diff_groups = sapply(train$month_diff, adj_month_diff)

woedf <- woe('month_diff_groups', train)
plotWoe('month_diff_groups', woedf)
```
# Linear regression model 

## Creating the input matrix for the model 

```{r finalframe}
colsModeling = c(
  "Y",
  "purpose",
  "term",
  "pub_rec_groups",
  "annual_inc_groups",
  "dti_groups",
  "month_diff_groups",
  "emp_length_groups",
  "int_rate_groups"
)

X = train[, ..colsModeling]

# Ensuring the correct datatype
X[,(colsModeling) := lapply(.SD, as.factor), .SDcols = colsModeling] 
```

## Creating the model 

```{r logistic}
model <- glm(Y ~ ., data=X, family=binomial(link='logit'))

summary(model)
```

# Model performance on the test set 

```{r preparing input}
test$pub_rec_groups <- sapply(test$pub_rec, adj_pub_rec)
test$annual_inc_groups <- sapply(test$annual_inc, adj_income)
test$dti_groups <- sapply(test$dti, adj_dti)
test$month_diff_groups <- sapply(test$month_diff, adj_month_diff)
test$emp_length_groups <- sapply(test$emp_length, adjust_emp_length)
test$int_rate_groups <- sapply(test$int_rate, adj_int_rate)

Xtest = test[, ..colsModeling]

# Ensuring the correct datatype
Xtest[,(colsModeling) := lapply(.SD, as.factor), .SDcols = colsModeling] 

# Getting the probabilities
yhat <- predict.glm(model, Xtest, type='response')
```

```{r inspecting the results}
test$yhat <- yhat

# Getting the ROC statistic 
ROC <- roc(test$Y, test$yhat)
roc_stat <- ROC$auc
ggroc(ROC) + geom_abline(intercept = 1, slope = 1, color='blue')
print(paste("AUC score: ", roc_stat))
print(paste("Gini score: ", 2 * roc_stat - 1))
```